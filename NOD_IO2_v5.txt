[Техническое задание - Определение НОД всех элементов массива]
[Используется Initial Orders 2]
[Длина массива задается в ячейке 55]
[Адрес первой ячейки массива задается в ячейке 56]
[Массив хранится в ячейках 57-64]
[Результат (НОД всех элементов массива) записывается в ячейку 0]

[Входные данные]
T 55 K [Входные данные размещаются с ячейки 55]
GK [@ = 55]
[@+0]	P 4 F	[<len> (=8) - длина массива]
[@+1]	P 28 D	[<addr> (=57) - адрес первой ячейки массива]
[@+2]	P 4 D 	[9]	
[@+3]	P 9 F 	[18]
[@+4]	P 15 F	[30]
[@+5]	P 30 F	[60]
[@+6]	P 60 F	[120]
[@+7]	P 18 F	[36]
[@+8]	P 16 D	[33]
[@+9]	P 12 F	[24]

[Подпрограмма нахождения НОД массива]
[Входные параметры: адрес ячейки с длиной массива - 55, адрес первой ячейки массива - 56]
[Результат (НОД) - в ячейке 0]
T 200 K [Подпрограмма размещается с ячейки 200]
GK [@ = 200]
[@+0]	A 3 F	[формирование инструкции возврата в аккумуляторе]
[@+1]	T 64 @ [<return>] [запись инструкции возврата, обнуление аккумулятора]
[В ячейке 1 хранится количество необработанных пар чисел (счетчик цикла)]
[Инициализация счетчика цикла]
[@+2]	A 55 F [<len>] [загрузка в аккумулятор длины массива]
[@+3]	S 65 @ [<c1>] [вычитаем единицу, т.к. количество пар чисел на 1 меньше, чем длина массива]
[@+4]	T 1 F [запись значения в ячейку 1]

[Инициализация адресных полей изменяемых инструкций]
[@+5]	A 56 F [<addr>] [Загрузка в аккумулятор адреса 0-го элемента массива]
[@+6]	L 0 D [Сдвиг аккумулятора на 1 разряд влево]
[@+7]	A 29 @ [<r1>] [Прибавляем код инструкции с нулевым полем адреса] [r1: A 0 F]
[@+8]	U 29 @ [<r1>] [Запись сформированной инструкции без обнуления аккумулятора]
[@+9]	T 62 @ [<r1>] [Запись сформированной инструкции с обнулением аккумулятора]

[@+10]	A 56 F [<addr>] [Загрузка в аккумулятор адреса 0-го элемента массива]
[@+11]	L 0 D [Сдвиг аккумулятора на 1 разряд влево]
[@+12]	A 30 @ [<r2>] [Прибавляем код инструкции с полем адреса 1] [r2: S 1 F]
[@+13]	U 30 @ [<r2>] [Запись сформированной инструкции без обнуления аккумулятора]
[@+14]	T 37 @ [<r2>] [Запись сформированной инструкции с обнулением аккумулятора]

[@+15]	A 56 F [<addr>] [Загрузка в аккумулятор адреса 0-го элемента массива]
[@+16]	L 0 D [Сдвиг аккумулятора на 1 разряд влево]
[@+17]	A 32 @ [<w1>] [Прибавляем код инструкции с нулевым полем адреса] [w1: U 0 F]
[@+18]	T 32 @ [<w1>] [Запись сформированной инструкции с обнулением аккумулятора]

[@+19]	A 56 F [<addr>] [Загрузка в аккумулятор адреса 0-го элемента массива]
[@+20]	L 0 D [Сдвиг аккумулятора на 1 разряд влево]
[@+21]	A 36 @ [<w2>] [Прибавляем код инструкции с полем адреса 1] [w2: T 1 F]
[@+22]	U 36 @ [<w2>] [Запись сформированной инструкции без обнуления аккумулятора]
[@+23]	T 38 @ [<w2>] [Запись сформированной инструкции с обнулением аккумулятора]

[Рабочий цикл]
[loop:]
[@+24]	A 1 F	[Загружаем в аккумулятор счетчик необработанных пар]
[@+25]	S 65 @ [<c1>] [Уменьшаем на 1]
[@+26]	G 61 @ [<end>] [Если результат меньше 0, то идем на выход из подпрограммы]
[@+27]	T 1 F [Обновляем значение счетчика в ячейке]
[Поиск НОД для пары]
[@+28]	T 0 F	[обнуление аккумулятора]
[@+29]	A 0 F	[r1:] [добавляем к аккумулятору первое число]
[@+30]	S 1 F	[r2:] [вычитаем из аккумулятора второе число]
[@+31]	G 36 @	[если результат отрицательный (первое число меньше второго), то идем к <invert>]
[@+32]	U 0 F	[w1:] [иначе в ячейку с первым числом кладем разность чисел, сохраняя ее в аккумуляторе]
[@+33]	S 65 @	[вычитаем из разности единицу и результат кладем в аккумулятор]
[@+34]	E 28 @	[если результат >=0, значит разность была >0, т.е. числа разные –> идем на следующую итерацию]
[@+35]	G 40 @	[<exit>] [числа одинаковые, НОД найден – выходим из цикла поиска НОД для пары чисел]
[invert:]
[@+36]	T 1 F	[w2:] [в ячейку со вторым числом кладем отрицательную разность, обнуляя аккумулятор]
[@+37]	S 1 F	[r2:] [вычитаем из нуля разность – фактически инвертируем знак!]
[@+38]	T 1 F	[w2:] [в ячейку со вторым числом кладем положительную разность, обнуляя аккумулятор]
[@+39]	E 28 @	[аккумулятор=0 –> идем к следующей итерации поиска НОД]

[exit:]
[Модификация адресных полей изменяемых инструкций для следующего шага рабочего цикла]
[@+40]	T 0 F [обнуляем аккумулятор]
[@+41]	A 65 @ [<c1>] [загрузка в аккумулятор константы 1]
[@+42]	L 0 D [сдвиг на 1 разряд влево]
[@+43]	A 29 @ [<r1>] [прибавляем код инструкции, исполненной на предыдущем шаге]
[@+44]	U 29 @ [<r1>] [записываем сформированную инструкцию в память, без обнуления аккумулятора]
[@+45]	T 62 @ [<r1>] [записываем сформированную инструкцию в память, с обнулением аккумулятора]

[@+46]	A 65 @ [<c1>] [загрузка в аккумулятор константы 1]
[@+47]	L 0 D [сдвиг на 1 разряд влево]
[@+48]	A 30 @ [<r2>] [прибавляем код инструкции, исполненной на предыдущем шаге]
[@+49]	U 30 @ [<r2>] [записываем сформированную инструкцию в память, без обнуления аккумулятора]
[@+50]	T 37 @ [<r2>] [записываем сформированную инструкцию в память, с обнулением аккумулятора]

[@+51]	A 65 @ [<c1>] [загрузка в аккумулятор константы 1]
[@+52]	L 0 D [сдвиг на 1 разряд влево]
[@+53]	A 32 @ [<w1>] [прибавляем код инструкции, исполненной на предыдущем шаге]
[@+54]	T 32 @ [<w1>] [записываем сформированную инструкцию в память, с обнулением аккумулятора]

[@+55]	A 65 @ [<c1>] [загрузка в аккумулятор константы 1]
[@+56]	L 0 D [сдвиг на 1 разряд влево]
[@+57]	A 36 @ [<r2>] [прибавляем код инструкции, исполненной на предыдущем шаге]
[@+58]	U 36 @ [<r2>] [записываем сформированную инструкцию в память, без обнуления аккумулятора]
[@+59]	T 38 @ [<r2>] [записываем сформированную инструкцию в память, с обнулением аккумулятора]

[@+60]	E 24 @ [<loop>] [аккумулятор=0 -> повторяем рабочий цикл]

[end:]
[@+61]	T 0 F [Обнуляем аккумулятор]
[@+62]	A 0 F [r1:] [Загружаем в аккумулятор найденный НОД массива]
[@+63]	T 0 F [Записываем его в ячейку 0]
[return:]
[@+64]	E 0 F [Возврат из подпрограммы]
[c1:]
[@+65]	P 0 D [константа 1]

[Вызывающая программа]
T 100 K [Программа размещается с ячейки 100]
GK [@ = 100]
[@+0]	Z 0 F	[останов для отладки]
[@+1]	T 0 F	[обнуление аккумулятора]
[@+2]	A 2 @	[запись в аккумулятор текущего адреса для формирования в подпрограмме инструкции возврата]
[@+3]	G 200 F	[вызов подпрограммы нахождения НОД массива]
[@+4]	Z 0 F	[останов]
[@+5]	EZPF	[переход к первой инструкции программы]
